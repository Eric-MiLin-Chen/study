## 第九题

这部分内容涉及《实验指导》第五部分中“有关信号处理的系统调用”。编程实现软中断信号通信。父进程设定软中断信号处理程序，向子进程发软中断信号。子进程收到信号后执行相应处理程序。

例程 7：软中断信号实验

```cpp
/* 父进程向子进程发送18 号软中断信号后等待。子进程收到信号，执行指定的程序，再将父进程唤醒。*/
#include <iostream>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

void func(int signal_number);

int main()
{
    int i, j, k;
    signal(18, func);    /*设置18号信号的处理程序*/
    if (i = fork())      /*创建子进程*/
    {                    /*父进程执行*/
        j = kill(i, 18); /*向子进程发送信号*/
        printf("Parent: signal 18 has been sent to child %d,returned %d.\n", i, j);
        k = wait(0); /*父进程被唤醒*/
        printf("After wait %d,Parent %d: finished.\n", k, getpid());
    }
    else
    { /*子进程执行*/
        sleep(10);
        printf("Child %d: A signal from my parent is recived.\n", getpid());
    } /*子进程结束，向父进程发子进程结束信号*/
}
void func(int signal_number) /*处理程序*/
{
    printf("I am Process %d: It is signal %d processing function.\n", getpid(), signal_number);
}
```

思考：这就是软中断信号处理，有点儿明白了吧？讨论一下它与硬中断有什么区别？看来还挺管用，好好利用它。

**软中断信号处理与硬中断的区别：**

1. **触发方式** ：

-   **软中断信号处理** ：由操作系统或其他进程向进程发送软中断信号，通常是通过系统调用、信号发送函数（如 `kill()`）等方式触发。软中断信号是由软件控制的，是一种协作机制。
-   **硬中断** ：由硬件事件触发，如外部设备（如键盘、鼠标、网络接口卡等）产生的中断请求。硬中断是由硬件控制的，是一种异步机制。

1. **处理方式** ：

-   **软中断信号处理** ：进程可以捕获和处理软中断信号，通常通过设置信号处理程序来执行自定义操作。软中断信号处理是进程级别的事件处理。
-   **硬中断** ：硬中断由操作系统的内核处理，它负责响应硬件事件并执行相应的处理操作。硬中断是内核级别的事件处理。

1. **响应时间** ：

-   **软中断信号处理** ：响应时间相对较短，取决于进程能够多快地处理信号。通常用于处理非实时事件。
-   **硬中断** ：响应时间通常更快，因为硬中断由硬件直接触发，可以用于实时系统中需要快速响应的事件。

1. **用途** ：

-   **软中断信号处理** ：用于进程间通信、自定义事件处理、控制进程行为等。它是一种高级的事件处理机制，可以实现多种自定义功能。
-   **硬中断** ：主要用于响应硬件事件，如输入设备、网络通信、存储设备等。硬中断是处理底层硬件事件的重要方式。

    **应用场景** ：

-   **软中断信号处理**通常用于进程级别的事件处理，如在用户级别的应用程序中捕获和处理信号，以执行自定义操作，如优雅退出、重新加载配置、处理自定义协议等。它也用于进程间通信，如通过消息队列、信号量等进行通信。
-   **硬中断**主要用于响应底层硬件事件，如输入设备（键盘、鼠标）、网络通信（网络接口中断）、存储设备（磁盘 I/O）等。硬中断的响应速度较快，适用于需要实时响应的场景，如嵌入式系统和实时操作系统。
