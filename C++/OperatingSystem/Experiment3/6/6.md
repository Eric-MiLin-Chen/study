## 第六题

参照《实验指导》第五部分中“管道操作的系统调用”。复习管道通信概念，参考例程 5，编写一个程序。父进程创建两个子进程，父子进程之间利用管道进行通信。要求能显示父进程、子进程各自的信息，体现通信效果。

例程 5：管道通信的实验

```cpp
/*程序建立一个管道fd*/
/*父进程创建两个子进程P1、P2 */
/*子进程P1、P2 分别向管道写入信息*/
/*父进程等待子进程结束，并读出管道中的信息*/
#include <iostream>
#include <sys/wait.h>
#include <unistd.h>

int main()
{
    int i, r, j, k, l, p1, p2, fd[2];
    char buf[50], s[50];
    pipe(fd);                   /*建立一个管道fd*/
    while ((p1 = fork()) == -1) /*创建子进程1*/
        ;
    if (p1 == 0) /*子进程1执行*/
    {
        lockf(fd[1], 1, 0); /*管道写入端加锁*/
        sprintf(buf, "Child process P1 is sending messages! \n");
        printf("Child process P1! \n");
        write(fd[1], buf, 50); /*信息写入管道*/
        lockf(fd[1], 0, 0);    /*管道写入端解锁*/
        sleep(5);
        j = getpid();
        k = getppid();
        printf("P1 %d is weakup. My parent process ID is %d.\n", j, k);
        exit(0);
    }
    else
    {
        while ((p2 = fork()) == -1) /*创建子进程2*/
            ;
        if (p2 == 0) /*子进程2执行*/
        {
            lockf(fd[1], 1, 0); /*管道写入端加锁*/
            sprintf(buf, "Child process P2 is sending messages! \n");
            printf("Child process P2! \n");
            write(fd[1], buf, 50); /*信息写入管道*/
            lockf(fd[1], 0, 0);    /*管道写入端解锁*/
            sleep(5);
            j = getpid();
            k = getppid();
            printf("P2 %d is weakup. My parent process ID is %d.\n", j, k);
            exit(0);
        }
        else
        {
            l = getpid();
            wait(0); /* 等待被唤醒*/
            if (r = read(fd[0], s, 50) == -1)
                printf("Can't read pipe. \n");
            else
                printf("Parent %d: %s \n", l, s);
            wait(0); /* 等待被唤醒*/
            if (r = read(fd[0], s, 50) == -1)
                printf("Can't read pipe. \n");
            else
                printf("Parent %d: %s \n", l, s);
            exit(0);
        }
    }
}
```

思考：
① 什么是管道？进程如何利用它进行通信的？解释一下实现方法。
② 修改睡眠时机、睡眠长度，看看会有什么变化。请解释。
③ 加锁、解锁起什么作用？不用它行吗？思考：子进程被创建后，对父进程的运行环境有影响吗？解释一下。

1. 管道是一种用于进程间通信的机制，允许一个进程将数据写入管道，而另一个进程可以从管道中读取这些数据。管道通常用于实现进程间的数据传递和协作。

    在 Unix 和类 Unix 系统中，有两种主要类型的管道：无名管道（通常称为匿名管道）和有名管道。

    - 无名管道：无名管道是一种特殊的文件，只存在于内存中，通常用于父子进程之间或者在创建子进程之前使用 `pipe()`系统调用创建。父进程将数据写入管道的一端，而子进程从另一端读取。这种通信方式是单向的，通常用于父子进程之间的通信。
    - 有名管道：有名管道是一种具有名称的特殊文件，存储在文件系统中。多个进程可以通过打开相同的有名管道来进行通信。这种通信方式可以是双向的，多进程可以在管道上进行读写操作，允许更复杂的进程间通信。

    实现无名管道的方法通常涉及以下步骤：

    1. 使用 `pipe()`系统调用创建管道。
    2. 使用 `fork()`系统调用创建子进程，父进程和子进程都会继承管道的文件描述符。
    3. 父进程关闭不需要的管道端，子进程关闭另一端。
    4. 父进程可以使用 `write()`来写入数据到管道，而子进程可以使用 `read()`来从管道中读取数据。

    实现有名管道的方法包括：

    1. 使用 `mkfifo()`系统调用创建有名管道文件。
    2. 多个进程可以打开这个有名管道文件，并像操作普通文件一样读取和写入数据。

2. 睡眠时机和睡眠长度的修改会对进程的行为和性能产生影响，当睡眠长度与时机不同步或产生重叠时可能出现写入管道的数据尚未被目标进程读取就被重新读取至本进程。

    - 睡眠时机：修改睡眠时机指的是更改进程在执行过程中选择进入睡眠状态的时间点。通常，进程会在等待某些条件满足或资源就绪时进入睡眠状态。如果修改睡眠时机，进程可能会更早或更晚地进入睡眠状态，这会影响进程的响应性和资源利用率。
    - 睡眠长度：修改睡眠长度指的是更改进程在睡眠状态下停留的时间。睡眠长度通常由进程自己或操作系统决定，以便等待事件的到来或资源的可用性。如果缩短睡眠长度，进程可能会更频繁地检查条件或资源，以获得更高的响应速度，但这可能会增加 CPU 负载。如果延长睡眠长度，进程可能会减少 CPU 使用，但响应速度可能会变慢。

3. 加锁和解锁通常用于多线程或多进程环境中，以确保对共享资源的访问是线程安全的。锁是一种同步机制，可以防止多个线程或进程同时访问或修改共享资源，以避免竞态条件和数据不一致性。

    作用：

    - 加锁：当一个线程或进程需要访问共享资源时，它会尝试获取锁。如果锁已经被其他线程或进程持有，那么请求锁的线程或进程会被阻塞，直到锁被释放。这确保了同一时间只有一个线程或进程能够访问共享资源，从而防止数据损坏或不一致性。
    - 解锁：当线程或进程完成对共享资源的访问后，它会释放锁，允许其他线程或进程获取锁并访问资源。

    在多线程或多进程环境中，通常使用互斥锁、信号量等同步原语来实现锁机制。

    不使用锁可能导致竞态条件，其中多个线程或进程试图同时修改共享资源，导致数据不一致性或程序崩溃。

    关于子进程对父进程的影响：
    子进程在创建后通常会运行在独立的进程空间中，它不会直接影响父进程的运行环境。子进程会继承父进程的某些属性，如文件描述符、环境变量等，但这些属性的修改通常不会影响到父进程。
